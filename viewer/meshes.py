# Mesh Generation

import math

import numpy as np

from utils import as_float_array, as_index_array, length, normalize


class Mesh(object):
    def __init__(self, vertices, faces, normals=None, colors=None):
        # Infer the direction of vertex normal as that of vector pointing
        # the vertex from the centroid of the vertices. This should give
        # fairly good normals for convex objects.
        if normals is None:
            center = np.mean(vertices, axis=0)
            normals = np.array(vertices) - center
            normals /= length(normals)[:, None]
        # Default color is white.
        if colors is None:
            colors = np.ones((len(vertices), 3))

        self.vertices = vertices
        self.faces = faces
        self.normals = normals
        self.colors = colors

    def copy(self):
        return Mesh(np.copy(as_float_array(self.vertices)),
                    np.copy(as_index_array(self.faces)),
                    np.copy(as_float_array(self.normals)),
                    np.copy(as_float_array(self.colors)))


def combine_meshes(meshes):
    """ Combine mesh objects into a single mesh
    """
    vertices = []
    faces = []
    normals = []
    colors = []

    for mesh in meshes:
        index_offset = len(vertices)
        vertices.extend(mesh.vertices)
        faces.extend(index_offset + i for i in mesh.faces)
        normals.extend(mesh.normals)
        colors.extend(mesh.colors)

    return Mesh(vertices, faces, normals, colors)


def generate_connective_cylinders(points, radius, ndiv):
    """ Generate mesh of cylinders of given radius along the segments
    connecting given sequence of points. Each cylinder is generated by
    dividing cylinder side into ndiv rectangular strips.
    """
    # Use template to reduce overhead of mesh generation.
    template_mesh = make_cylinder_mesh(ndiv)
    template_mesh.vertices[:, 0] *= radius
    template_mesh.vertices[:, 1] *= radius

    meshes = []
    for point_1, point_2 in zip(points[:-1], points[1:]):
        # Compute orthonormal frame whose z-axis is given by the tangent
        # vector of the segment connecting two points. Then we will map the
        # template cylinder mesh along the z-axis.
        segment = point_2 - point_1
        tangent = normalize(segment)
        try:
            normal = find_any_normal(tangent)
        except:
            normal = [1, 0, 0]
        binormal = np.cross(tangent, normal)
        frame = np.row_stack((normal, binormal, tangent))

        # Map template mesh on the segment.
        stretch = length(segment)
        mesh = template_mesh.copy()
        mesh.vertices[:, 2] *= stretch
        mesh.vertices = np.dot(mesh.vertices, frame) + point_1
        mesh.normals = np.dot(mesh.normals, frame)
        meshes.append(mesh)

    return meshes


def find_any_normal(vec):
    """ Return a unit vector perpendicular to the given nonzero vector.
    """
    x, y, z = vec
    candidates = [
        (y + z,    -x,    -x),
        (   -y, z + x,    -y),
        (   -z,    -z, x + y),
        (y - z,    -x,     x),
        (    y, z - x,    -y),
        (   -z,     z, x - y)
    ]

    for n in candidates:
        norm = length(n)
        if norm > 0:
            return as_float_array(n) / norm

    raise Exception('cannot find a normal')


def generate_spheres(points, radius, ndiv):
    """ Generate mesh of spheres of given radius centered at given points.
    Each sphere is generated by subdividing icosahedron mesh ndiv-times.
    """
    # Use template to reduce overhead of mesh generation.
    template_mesh = make_sphere_mesh(ndiv)
    template_mesh.vertices *= radius

    meshes = []
    for point in points:
        mesh = template_mesh.copy()
        mesh.vertices += point # Translate to the point
        meshes.append(mesh)
    return meshes


def make_icosahedron_mesh():
    """ Return a Mesh object representing triangulated icosahedron.
    """
    t = (1 + math.sqrt(5)) / 2
    a = t / math.hypot(1, t)
    b = 1 / math.hypot(1, t)
    vertices = as_float_array([
        ( a,  b,  0),
        (-a,  b,  0),
        ( a, -b,  0),
        (-a, -b,  0),
        ( b,  0,  a),
        ( b,  0, -a),
        (-b,  0,  a),
        (-b,  0, -a),
        ( 0,  a,  b),
        ( 0, -a,  b),
        ( 0,  a, -b),
        ( 0, -a, -b)
    ])
    faces = as_index_array([
        ( 0,  8,  4),
        ( 0,  5, 10),
        ( 2,  4,  9),
        ( 2, 11,  5),
        ( 1,  6,  8),
        ( 1, 10,  7),
        ( 3,  9,  6),
        ( 3,  7, 11),
        ( 0, 10,  8),
        ( 1,  8, 10),
        ( 2,  9, 11),
        ( 3,  9, 11),
        ( 4,  2,  0),
        ( 5,  0,  2),
        ( 6,  1,  3),
        ( 7,  3,  1),
        ( 8,  6,  4),
        ( 9,  4,  6),
        (10,  5,  7),
        (11,  7,  5)
    ])
    return Mesh(vertices, faces)


def make_sphere_mesh(ndiv=1):
    """ Return a Mesh object representing triangulated unit sphere.
    """

    # Subdivide each face of icosahedron mesh ndiv times to get a model of
    # the unit sphere.
    icosahedron = make_icosahedron_mesh()
    vertices = list(icosahedron.vertices)
    faces = list(icosahedron.faces)

    for _ in range(ndiv):
        prev_faces = faces
        faces = list()
        used_indices = dict()

        for face in prev_faces:
            # Add vertices at the midpoint of each edge of the face:
            #
            #       f2                     f2
            #       /\                     /\
            #      /  \                   /  \
            #     /    \      --->    i1 /----\ i0
            #    /      \               / \  / \
            #   /________\             /___\/___\
            # f0          f1         f0    i2    f1
            #
            # The midpoint may already be added earlier in processing of one
            # of the adjacent faces. In that case we reuse the previously-
            # added vertex and its index saved in used_indices.
            edges = [
                (face[1], face[2]),
                (face[2], face[0]),
                (face[0], face[1])
            ]
            mid_indices = []
            for s, t in edges:
                key = tuple(sorted((s, t)))
                if key in used_indices:
                    index = used_indices[key]
                else:
                    index = len(vertices)
                    vertex = midpoint_on_sphere(vertices[s], vertices[t])
                    vertices.append(vertex)
                    used_indices[key] = index
                mid_indices.append(index)

            # Build new faces. See the figure above.
            index_0, index_1, index_2 = mid_indices
            faces.append((index_0, index_1, index_2)) # i0-i1-i2
            faces.append((face[0], index_2, index_1)) # f0-i2-i1
            faces.append((index_2, face[1], index_0)) # i2-f1-i0
            faces.append((index_1, index_0, face[2])) # i1-i0-f2

    vertices = as_float_array(vertices)
    faces = as_index_array(faces)

    return Mesh(vertices, faces)


def midpoint_on_sphere(p1, p2):
    """ Given two points on a unit sphere returns the midpoint on the same
    sphere.
    """
    return normalize(p1 + p2)


def make_cylinder_mesh(ndiv=7):
    """ Return a Mesh object representing triangulated cylinder along the
    z-axis. The radius and the height of the cylinder is 1.
    """

    # First create the circle at the bottom of the cylinder for reference.
    angle = np.linspace(0, 2 * math.pi, num=ndiv, endpoint=False)
    xs = np.cos(angle)
    ys = np.sin(angle)
    zs = np.zeros(len(xs))
    cross_section = np.transpose((xs, ys, zs))
    axis = np.array((0, 0, 1))

    # Then triangulate the side of the cylinder by connecting bottom and top
    # circles by series of right triangles.
    vertices = []
    normals = []
    for vert in cross_section:
        vertices.append(vert)
        vertices.append(vert + axis)
        normal = normalize(vert)
        normals.append(normal)
        normals.append(normal)

    faces = []
    n = len(vertices)
    for i in range(0, n, 2):
        faces.append((i,      i + 1,      (i + 2) % n))
        faces.append((i + 1, (i + 2) % n, (i + 3) % n))

    vertices = as_float_array(vertices)
    faces = as_index_array(faces)
    normals = as_float_array(normals)

    return Mesh(vertices, faces, normals)
